{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _inheritsLoose from \"@babel/runtime/helpers/esm/inheritsLoose\";\nimport { getStatusProps, isServer, isValidTimeout, noop, replaceEqualDeep, shallowEqualObjects, timeUntilStale } from './utils';\nimport { notifyManager } from './notifyManager';\nimport { focusManager } from './focusManager';\nimport { Subscribable } from './subscribable';\nexport var QueryObserver = /*#__PURE__*/function (_Subscribable) {\n  _inheritsLoose(QueryObserver, _Subscribable);\n\n  function QueryObserver(client, options) {\n    var _this;\n\n    _this = _Subscribable.call(this) || this;\n    _this.client = client;\n    _this.options = options;\n    _this.initialDataUpdateCount = 0;\n    _this.initialErrorUpdateCount = 0;\n\n    _this.bindMethods();\n\n    _this.setOptions(options);\n\n    return _this;\n  }\n\n  var _proto = QueryObserver.prototype;\n\n  _proto.bindMethods = function bindMethods() {\n    this.remove = this.remove.bind(this);\n    this.refetch = this.refetch.bind(this);\n  };\n\n  _proto.onSubscribe = function onSubscribe() {\n    if (this.listeners.length === 1) {\n      this.updateQuery();\n      this.currentQuery.addObserver(this);\n\n      if (this.willFetchOnMount()) {\n        this.executeFetch();\n      }\n\n      this.updateTimers();\n    }\n  };\n\n  _proto.onUnsubscribe = function onUnsubscribe() {\n    if (!this.listeners.length) {\n      this.destroy();\n    }\n  };\n\n  _proto.willLoadOnMount = function willLoadOnMount() {\n    return this.options.enabled !== false && !this.currentQuery.state.dataUpdatedAt && !(this.currentQuery.state.status === 'error' && this.options.retryOnMount === false);\n  };\n\n  _proto.willRefetchOnMount = function willRefetchOnMount() {\n    return this.options.enabled !== false && this.currentQuery.state.dataUpdatedAt > 0 && (this.options.refetchOnMount === 'always' || this.options.refetchOnMount !== false && this.isStale());\n  };\n\n  _proto.willFetchOnMount = function willFetchOnMount() {\n    return this.willLoadOnMount() || this.willRefetchOnMount();\n  };\n\n  _proto.willFetchOnReconnect = function willFetchOnReconnect() {\n    return this.options.enabled !== false && (this.options.refetchOnReconnect === 'always' || this.options.refetchOnReconnect !== false && this.isStale());\n  };\n\n  _proto.willFetchOnWindowFocus = function willFetchOnWindowFocus() {\n    return this.options.enabled !== false && (this.options.refetchOnWindowFocus === 'always' || this.options.refetchOnWindowFocus !== false && this.isStale());\n  };\n\n  _proto.willFetchOptionally = function willFetchOptionally() {\n    return this.options.enabled !== false && this.isStale();\n  };\n\n  _proto.isStale = function isStale() {\n    return this.currentQuery.isStaleByTime(this.options.staleTime);\n  };\n\n  _proto.destroy = function destroy() {\n    this.listeners = [];\n    this.clearTimers();\n    this.currentQuery.removeObserver(this);\n  };\n\n  _proto.setOptions = function setOptions(options) {\n    var prevOptions = this.options;\n    var prevQuery = this.currentQuery;\n    this.options = this.client.defaultQueryObserverOptions(options);\n\n    if (typeof this.options.enabled !== 'undefined' && typeof this.options.enabled !== 'boolean') {\n      throw new Error('Expected enabled to be a boolean');\n    } // Keep previous query key if the user does not supply one\n\n\n    if (!this.options.queryKey) {\n      this.options.queryKey = prevOptions.queryKey;\n    }\n\n    this.updateQuery(); // Take no further actions if there are no subscribers\n\n    if (!this.listeners.length) {\n      return;\n    } // If we subscribed to a new query, optionally fetch and update refetch\n\n\n    if (this.currentQuery !== prevQuery) {\n      this.optionalFetch();\n      this.updateTimers();\n      return;\n    } // Optionally fetch if the query became enabled\n\n\n    if (this.options.enabled !== false && prevOptions.enabled === false) {\n      this.optionalFetch();\n    } // Update stale interval if needed\n\n\n    if (this.options.enabled !== prevOptions.enabled || this.options.staleTime !== prevOptions.staleTime) {\n      this.updateStaleTimeout();\n    } // Update refetch interval if needed\n\n\n    if (this.options.enabled !== prevOptions.enabled || this.options.refetchInterval !== prevOptions.refetchInterval) {\n      this.updateRefetchInterval();\n    }\n  };\n\n  _proto.getCurrentResult = function getCurrentResult() {\n    return this.currentResult;\n  };\n\n  _proto.getNextResult = function getNextResult(options) {\n    var _this2 = this;\n\n    return new Promise(function (resolve, reject) {\n      var unsubscribe = _this2.subscribe(function (result) {\n        if (!result.isFetching) {\n          unsubscribe();\n\n          if (result.isError && (options == null ? void 0 : options.throwOnError)) {\n            reject(result.error);\n          } else {\n            resolve(result);\n          }\n        }\n      });\n    });\n  };\n\n  _proto.getCurrentQuery = function getCurrentQuery() {\n    return this.currentQuery;\n  };\n\n  _proto.remove = function remove() {\n    this.client.getQueryCache().remove(this.currentQuery);\n  };\n\n  _proto.refetch = function refetch(options) {\n    return this.fetch(options);\n  };\n\n  _proto.fetch = function fetch(fetchOptions) {\n    var _this3 = this;\n\n    return this.executeFetch(fetchOptions).then(function () {\n      _this3.updateResult();\n\n      return _this3.currentResult;\n    });\n  };\n\n  _proto.optionalFetch = function optionalFetch() {\n    if (this.willFetchOptionally()) {\n      this.executeFetch();\n    }\n  };\n\n  _proto.executeFetch = function executeFetch(fetchOptions) {\n    // Make sure we reference the latest query as the current one might have been removed\n    this.updateQuery(); // Fetch\n\n    var promise = this.currentQuery.fetch(this.options, fetchOptions);\n\n    if (!(fetchOptions == null ? void 0 : fetchOptions.throwOnError)) {\n      promise = promise.catch(noop);\n    }\n\n    return promise;\n  };\n\n  _proto.updateStaleTimeout = function updateStaleTimeout() {\n    var _this4 = this;\n\n    this.clearStaleTimeout();\n\n    if (isServer || this.currentResult.isStale || !isValidTimeout(this.options.staleTime)) {\n      return;\n    }\n\n    var time = timeUntilStale(this.currentResult.dataUpdatedAt, this.options.staleTime); // The timeout is sometimes triggered 1 ms before the stale time expiration.\n    // To mitigate this issue we always add 1 ms to the timeout.\n\n    var timeout = time + 1;\n    this.staleTimeoutId = setTimeout(function () {\n      if (!_this4.currentResult.isStale) {\n        var prevResult = _this4.currentResult;\n\n        _this4.updateResult();\n\n        _this4.notify({\n          listeners: _this4.shouldNotifyListeners(prevResult, _this4.currentResult),\n          cache: true\n        });\n      }\n    }, timeout);\n  };\n\n  _proto.updateRefetchInterval = function updateRefetchInterval() {\n    var _this5 = this;\n\n    this.clearRefetchInterval();\n\n    if (isServer || this.options.enabled === false || !isValidTimeout(this.options.refetchInterval)) {\n      return;\n    }\n\n    this.refetchIntervalId = setInterval(function () {\n      if (_this5.options.refetchIntervalInBackground || focusManager.isFocused()) {\n        _this5.executeFetch();\n      }\n    }, this.options.refetchInterval);\n  };\n\n  _proto.updateTimers = function updateTimers() {\n    this.updateStaleTimeout();\n    this.updateRefetchInterval();\n  };\n\n  _proto.clearTimers = function clearTimers() {\n    this.clearStaleTimeout();\n    this.clearRefetchInterval();\n  };\n\n  _proto.clearStaleTimeout = function clearStaleTimeout() {\n    clearTimeout(this.staleTimeoutId);\n    this.staleTimeoutId = undefined;\n  };\n\n  _proto.clearRefetchInterval = function clearRefetchInterval() {\n    clearInterval(this.refetchIntervalId);\n    this.refetchIntervalId = undefined;\n  };\n\n  _proto.getNewResult = function getNewResult(willFetch) {\n    var _this$previousQueryRe;\n\n    var state = this.currentQuery.state;\n    var isFetching = state.isFetching,\n        status = state.status;\n    var isPreviousData = false;\n    var isPlaceholderData = false;\n    var data;\n    var dataUpdatedAt = state.dataUpdatedAt; // Optimistically set status to loading if we will start fetching\n\n    if (willFetch) {\n      isFetching = true;\n\n      if (!dataUpdatedAt) {\n        status = 'loading';\n      }\n    } // Keep previous data if needed\n\n\n    if (this.options.keepPreviousData && !state.dataUpdateCount && ((_this$previousQueryRe = this.previousQueryResult) == null ? void 0 : _this$previousQueryRe.isSuccess)) {\n      data = this.previousQueryResult.data;\n      dataUpdatedAt = this.previousQueryResult.dataUpdatedAt;\n      status = this.previousQueryResult.status;\n      isPreviousData = true;\n    } // Select data if needed\n    else if (this.options.select && typeof state.data !== 'undefined') {\n        var _this$currentResultSt; // Use the previous select result if the query data did not change\n\n\n        if (this.currentResult && state.data === ((_this$currentResultSt = this.currentResultState) == null ? void 0 : _this$currentResultSt.data)) {\n          data = this.currentResult.data;\n        } else {\n          data = this.options.select(state.data);\n\n          if (this.options.structuralSharing !== false) {\n            var _this$currentResult;\n\n            data = replaceEqualDeep((_this$currentResult = this.currentResult) == null ? void 0 : _this$currentResult.data, data);\n          }\n        }\n      } // Use query data\n      else {\n          data = state.data;\n        } // Show placeholder data if needed\n\n\n    if (typeof this.options.placeholderData !== 'undefined' && typeof data === 'undefined' && status === 'loading') {\n      var placeholderData = typeof this.options.placeholderData === 'function' ? this.options.placeholderData() : this.options.placeholderData;\n\n      if (typeof placeholderData !== 'undefined') {\n        status = 'success';\n        data = placeholderData;\n        isPlaceholderData = true;\n      }\n    }\n\n    var result = _extends({}, getStatusProps(status), {\n      data: data,\n      dataUpdatedAt: dataUpdatedAt,\n      error: state.error,\n      errorUpdatedAt: state.errorUpdatedAt,\n      failureCount: state.fetchFailureCount,\n      isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,\n      isFetchedAfterMount: state.dataUpdateCount > this.initialDataUpdateCount || state.errorUpdateCount > this.initialErrorUpdateCount,\n      isFetching: isFetching,\n      isLoadingError: status === 'error' && state.dataUpdatedAt === 0,\n      isPlaceholderData: isPlaceholderData,\n      isPreviousData: isPreviousData,\n      isRefetchError: status === 'error' && state.dataUpdatedAt !== 0,\n      isStale: this.isStale(),\n      refetch: this.refetch,\n      remove: this.remove\n    });\n\n    return result;\n  };\n\n  _proto.shouldNotifyListeners = function shouldNotifyListeners(prevResult, result) {\n    var _this$options = this.options,\n        notifyOnChangeProps = _this$options.notifyOnChangeProps,\n        notifyOnChangePropsExclusions = _this$options.notifyOnChangePropsExclusions;\n\n    if (prevResult === result) {\n      return false;\n    }\n\n    if (!notifyOnChangeProps && !notifyOnChangePropsExclusions) {\n      return true;\n    }\n\n    var keys = Object.keys(result);\n\n    var _loop = function _loop(i) {\n      var key = keys[i];\n      var changed = prevResult[key] !== result[key];\n      var isIncluded = notifyOnChangeProps == null ? void 0 : notifyOnChangeProps.some(function (x) {\n        return x === key;\n      });\n      var isExcluded = notifyOnChangePropsExclusions == null ? void 0 : notifyOnChangePropsExclusions.some(function (x) {\n        return x === key;\n      });\n\n      if (changed) {\n        if (notifyOnChangePropsExclusions && isExcluded) {\n          return \"continue\";\n        }\n\n        if (!notifyOnChangeProps || isIncluded) {\n          return {\n            v: true\n          };\n        }\n      }\n    };\n\n    for (var i = 0; i < keys.length; i++) {\n      var _ret = _loop(i);\n\n      if (_ret === \"continue\") continue;\n      if (typeof _ret === \"object\") return _ret.v;\n    }\n\n    return false;\n  };\n\n  _proto.updateResult = function updateResult(willFetch) {\n    var result = this.getNewResult(willFetch); // Keep reference to the current state on which the current result is based on\n\n    this.currentResultState = this.currentQuery.state; // Only update if something has changed\n\n    if (!shallowEqualObjects(result, this.currentResult)) {\n      this.currentResult = result;\n    }\n  };\n\n  _proto.updateQuery = function updateQuery() {\n    var prevQuery = this.currentQuery;\n    var query = this.client.getQueryCache().build(this.client, this.options);\n\n    if (query === prevQuery) {\n      return;\n    }\n\n    this.previousQueryResult = this.currentResult;\n    this.currentQuery = query;\n    this.initialDataUpdateCount = query.state.dataUpdateCount;\n    this.initialErrorUpdateCount = query.state.errorUpdateCount;\n    var willFetch = prevQuery ? this.willFetchOptionally() : this.willFetchOnMount();\n    this.updateResult(willFetch);\n\n    if (!this.hasListeners()) {\n      return;\n    }\n\n    prevQuery == null ? void 0 : prevQuery.removeObserver(this);\n    this.currentQuery.addObserver(this);\n\n    if (this.shouldNotifyListeners(this.previousQueryResult, this.currentResult)) {\n      this.notify({\n        listeners: true\n      });\n    }\n  };\n\n  _proto.onQueryUpdate = function onQueryUpdate(action) {\n    // Store current result and get new result\n    var prevResult = this.currentResult;\n    this.updateResult();\n    var currentResult = this.currentResult; // Update timers\n\n    this.updateTimers(); // Do not notify if the nothing has changed\n\n    if (prevResult === currentResult) {\n      return;\n    } // Determine which callbacks to trigger\n\n\n    var notifyOptions = {};\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = true;\n    } else if (action.type === 'error') {\n      notifyOptions.onError = true;\n    }\n\n    if (this.shouldNotifyListeners(prevResult, currentResult)) {\n      notifyOptions.listeners = true;\n    }\n\n    this.notify(notifyOptions);\n  };\n\n  _proto.notify = function notify(notifyOptions) {\n    var _this6 = this;\n\n    notifyManager.batch(function () {\n      // First trigger the configuration callbacks\n      if (notifyOptions.onSuccess) {\n        _this6.options.onSuccess == null ? void 0 : _this6.options.onSuccess(_this6.currentResult.data);\n        _this6.options.onSettled == null ? void 0 : _this6.options.onSettled(_this6.currentResult.data, null);\n      } else if (notifyOptions.onError) {\n        _this6.options.onError == null ? void 0 : _this6.options.onError(_this6.currentResult.error);\n        _this6.options.onSettled == null ? void 0 : _this6.options.onSettled(undefined, _this6.currentResult.error);\n      } // Then trigger the listeners\n\n\n      if (notifyOptions.listeners) {\n        _this6.listeners.forEach(function (listener) {\n          listener(_this6.currentResult);\n        });\n      } // Then the cache listeners\n\n\n      if (notifyOptions.cache) {\n        _this6.client.getQueryCache().notify(_this6.currentQuery);\n      }\n    });\n  };\n\n  return QueryObserver;\n}(Subscribable);","map":{"version":3,"sources":["/home/gudu/Desktop/react-shopping-cart-main/node_modules/react-query/es/core/queryObserver.js"],"names":["_extends","_inheritsLoose","getStatusProps","isServer","isValidTimeout","noop","replaceEqualDeep","shallowEqualObjects","timeUntilStale","notifyManager","focusManager","Subscribable","QueryObserver","_Subscribable","client","options","_this","call","initialDataUpdateCount","initialErrorUpdateCount","bindMethods","setOptions","_proto","prototype","remove","bind","refetch","onSubscribe","listeners","length","updateQuery","currentQuery","addObserver","willFetchOnMount","executeFetch","updateTimers","onUnsubscribe","destroy","willLoadOnMount","enabled","state","dataUpdatedAt","status","retryOnMount","willRefetchOnMount","refetchOnMount","isStale","willFetchOnReconnect","refetchOnReconnect","willFetchOnWindowFocus","refetchOnWindowFocus","willFetchOptionally","isStaleByTime","staleTime","clearTimers","removeObserver","prevOptions","prevQuery","defaultQueryObserverOptions","Error","queryKey","optionalFetch","updateStaleTimeout","refetchInterval","updateRefetchInterval","getCurrentResult","currentResult","getNextResult","_this2","Promise","resolve","reject","unsubscribe","subscribe","result","isFetching","isError","throwOnError","error","getCurrentQuery","getQueryCache","fetch","fetchOptions","_this3","then","updateResult","promise","catch","_this4","clearStaleTimeout","time","timeout","staleTimeoutId","setTimeout","prevResult","notify","shouldNotifyListeners","cache","_this5","clearRefetchInterval","refetchIntervalId","setInterval","refetchIntervalInBackground","isFocused","clearTimeout","undefined","clearInterval","getNewResult","willFetch","_this$previousQueryRe","isPreviousData","isPlaceholderData","data","keepPreviousData","dataUpdateCount","previousQueryResult","isSuccess","select","_this$currentResultSt","currentResultState","structuralSharing","_this$currentResult","placeholderData","errorUpdatedAt","failureCount","fetchFailureCount","isFetched","errorUpdateCount","isFetchedAfterMount","isLoadingError","isRefetchError","_this$options","notifyOnChangeProps","notifyOnChangePropsExclusions","keys","Object","_loop","i","key","changed","isIncluded","some","x","isExcluded","v","_ret","query","build","hasListeners","onQueryUpdate","action","notifyOptions","type","onSuccess","onError","_this6","batch","onSettled","forEach","listener"],"mappings":"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","sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _inheritsLoose from \"@babel/runtime/helpers/esm/inheritsLoose\";\nimport { getStatusProps, isServer, isValidTimeout, noop, replaceEqualDeep, shallowEqualObjects, timeUntilStale } from './utils';\nimport { notifyManager } from './notifyManager';\nimport { focusManager } from './focusManager';\nimport { Subscribable } from './subscribable';\nexport var QueryObserver = /*#__PURE__*/function (_Subscribable) {\n  _inheritsLoose(QueryObserver, _Subscribable);\n\n  function QueryObserver(client, options) {\n    var _this;\n\n    _this = _Subscribable.call(this) || this;\n    _this.client = client;\n    _this.options = options;\n    _this.initialDataUpdateCount = 0;\n    _this.initialErrorUpdateCount = 0;\n\n    _this.bindMethods();\n\n    _this.setOptions(options);\n\n    return _this;\n  }\n\n  var _proto = QueryObserver.prototype;\n\n  _proto.bindMethods = function bindMethods() {\n    this.remove = this.remove.bind(this);\n    this.refetch = this.refetch.bind(this);\n  };\n\n  _proto.onSubscribe = function onSubscribe() {\n    if (this.listeners.length === 1) {\n      this.updateQuery();\n      this.currentQuery.addObserver(this);\n\n      if (this.willFetchOnMount()) {\n        this.executeFetch();\n      }\n\n      this.updateTimers();\n    }\n  };\n\n  _proto.onUnsubscribe = function onUnsubscribe() {\n    if (!this.listeners.length) {\n      this.destroy();\n    }\n  };\n\n  _proto.willLoadOnMount = function willLoadOnMount() {\n    return this.options.enabled !== false && !this.currentQuery.state.dataUpdatedAt && !(this.currentQuery.state.status === 'error' && this.options.retryOnMount === false);\n  };\n\n  _proto.willRefetchOnMount = function willRefetchOnMount() {\n    return this.options.enabled !== false && this.currentQuery.state.dataUpdatedAt > 0 && (this.options.refetchOnMount === 'always' || this.options.refetchOnMount !== false && this.isStale());\n  };\n\n  _proto.willFetchOnMount = function willFetchOnMount() {\n    return this.willLoadOnMount() || this.willRefetchOnMount();\n  };\n\n  _proto.willFetchOnReconnect = function willFetchOnReconnect() {\n    return this.options.enabled !== false && (this.options.refetchOnReconnect === 'always' || this.options.refetchOnReconnect !== false && this.isStale());\n  };\n\n  _proto.willFetchOnWindowFocus = function willFetchOnWindowFocus() {\n    return this.options.enabled !== false && (this.options.refetchOnWindowFocus === 'always' || this.options.refetchOnWindowFocus !== false && this.isStale());\n  };\n\n  _proto.willFetchOptionally = function willFetchOptionally() {\n    return this.options.enabled !== false && this.isStale();\n  };\n\n  _proto.isStale = function isStale() {\n    return this.currentQuery.isStaleByTime(this.options.staleTime);\n  };\n\n  _proto.destroy = function destroy() {\n    this.listeners = [];\n    this.clearTimers();\n    this.currentQuery.removeObserver(this);\n  };\n\n  _proto.setOptions = function setOptions(options) {\n    var prevOptions = this.options;\n    var prevQuery = this.currentQuery;\n    this.options = this.client.defaultQueryObserverOptions(options);\n\n    if (typeof this.options.enabled !== 'undefined' && typeof this.options.enabled !== 'boolean') {\n      throw new Error('Expected enabled to be a boolean');\n    } // Keep previous query key if the user does not supply one\n\n\n    if (!this.options.queryKey) {\n      this.options.queryKey = prevOptions.queryKey;\n    }\n\n    this.updateQuery(); // Take no further actions if there are no subscribers\n\n    if (!this.listeners.length) {\n      return;\n    } // If we subscribed to a new query, optionally fetch and update refetch\n\n\n    if (this.currentQuery !== prevQuery) {\n      this.optionalFetch();\n      this.updateTimers();\n      return;\n    } // Optionally fetch if the query became enabled\n\n\n    if (this.options.enabled !== false && prevOptions.enabled === false) {\n      this.optionalFetch();\n    } // Update stale interval if needed\n\n\n    if (this.options.enabled !== prevOptions.enabled || this.options.staleTime !== prevOptions.staleTime) {\n      this.updateStaleTimeout();\n    } // Update refetch interval if needed\n\n\n    if (this.options.enabled !== prevOptions.enabled || this.options.refetchInterval !== prevOptions.refetchInterval) {\n      this.updateRefetchInterval();\n    }\n  };\n\n  _proto.getCurrentResult = function getCurrentResult() {\n    return this.currentResult;\n  };\n\n  _proto.getNextResult = function getNextResult(options) {\n    var _this2 = this;\n\n    return new Promise(function (resolve, reject) {\n      var unsubscribe = _this2.subscribe(function (result) {\n        if (!result.isFetching) {\n          unsubscribe();\n\n          if (result.isError && (options == null ? void 0 : options.throwOnError)) {\n            reject(result.error);\n          } else {\n            resolve(result);\n          }\n        }\n      });\n    });\n  };\n\n  _proto.getCurrentQuery = function getCurrentQuery() {\n    return this.currentQuery;\n  };\n\n  _proto.remove = function remove() {\n    this.client.getQueryCache().remove(this.currentQuery);\n  };\n\n  _proto.refetch = function refetch(options) {\n    return this.fetch(options);\n  };\n\n  _proto.fetch = function fetch(fetchOptions) {\n    var _this3 = this;\n\n    return this.executeFetch(fetchOptions).then(function () {\n      _this3.updateResult();\n\n      return _this3.currentResult;\n    });\n  };\n\n  _proto.optionalFetch = function optionalFetch() {\n    if (this.willFetchOptionally()) {\n      this.executeFetch();\n    }\n  };\n\n  _proto.executeFetch = function executeFetch(fetchOptions) {\n    // Make sure we reference the latest query as the current one might have been removed\n    this.updateQuery(); // Fetch\n\n    var promise = this.currentQuery.fetch(this.options, fetchOptions);\n\n    if (!(fetchOptions == null ? void 0 : fetchOptions.throwOnError)) {\n      promise = promise.catch(noop);\n    }\n\n    return promise;\n  };\n\n  _proto.updateStaleTimeout = function updateStaleTimeout() {\n    var _this4 = this;\n\n    this.clearStaleTimeout();\n\n    if (isServer || this.currentResult.isStale || !isValidTimeout(this.options.staleTime)) {\n      return;\n    }\n\n    var time = timeUntilStale(this.currentResult.dataUpdatedAt, this.options.staleTime); // The timeout is sometimes triggered 1 ms before the stale time expiration.\n    // To mitigate this issue we always add 1 ms to the timeout.\n\n    var timeout = time + 1;\n    this.staleTimeoutId = setTimeout(function () {\n      if (!_this4.currentResult.isStale) {\n        var prevResult = _this4.currentResult;\n\n        _this4.updateResult();\n\n        _this4.notify({\n          listeners: _this4.shouldNotifyListeners(prevResult, _this4.currentResult),\n          cache: true\n        });\n      }\n    }, timeout);\n  };\n\n  _proto.updateRefetchInterval = function updateRefetchInterval() {\n    var _this5 = this;\n\n    this.clearRefetchInterval();\n\n    if (isServer || this.options.enabled === false || !isValidTimeout(this.options.refetchInterval)) {\n      return;\n    }\n\n    this.refetchIntervalId = setInterval(function () {\n      if (_this5.options.refetchIntervalInBackground || focusManager.isFocused()) {\n        _this5.executeFetch();\n      }\n    }, this.options.refetchInterval);\n  };\n\n  _proto.updateTimers = function updateTimers() {\n    this.updateStaleTimeout();\n    this.updateRefetchInterval();\n  };\n\n  _proto.clearTimers = function clearTimers() {\n    this.clearStaleTimeout();\n    this.clearRefetchInterval();\n  };\n\n  _proto.clearStaleTimeout = function clearStaleTimeout() {\n    clearTimeout(this.staleTimeoutId);\n    this.staleTimeoutId = undefined;\n  };\n\n  _proto.clearRefetchInterval = function clearRefetchInterval() {\n    clearInterval(this.refetchIntervalId);\n    this.refetchIntervalId = undefined;\n  };\n\n  _proto.getNewResult = function getNewResult(willFetch) {\n    var _this$previousQueryRe;\n\n    var state = this.currentQuery.state;\n    var isFetching = state.isFetching,\n        status = state.status;\n    var isPreviousData = false;\n    var isPlaceholderData = false;\n    var data;\n    var dataUpdatedAt = state.dataUpdatedAt; // Optimistically set status to loading if we will start fetching\n\n    if (willFetch) {\n      isFetching = true;\n\n      if (!dataUpdatedAt) {\n        status = 'loading';\n      }\n    } // Keep previous data if needed\n\n\n    if (this.options.keepPreviousData && !state.dataUpdateCount && ((_this$previousQueryRe = this.previousQueryResult) == null ? void 0 : _this$previousQueryRe.isSuccess)) {\n      data = this.previousQueryResult.data;\n      dataUpdatedAt = this.previousQueryResult.dataUpdatedAt;\n      status = this.previousQueryResult.status;\n      isPreviousData = true;\n    } // Select data if needed\n    else if (this.options.select && typeof state.data !== 'undefined') {\n        var _this$currentResultSt;\n\n        // Use the previous select result if the query data did not change\n        if (this.currentResult && state.data === ((_this$currentResultSt = this.currentResultState) == null ? void 0 : _this$currentResultSt.data)) {\n          data = this.currentResult.data;\n        } else {\n          data = this.options.select(state.data);\n\n          if (this.options.structuralSharing !== false) {\n            var _this$currentResult;\n\n            data = replaceEqualDeep((_this$currentResult = this.currentResult) == null ? void 0 : _this$currentResult.data, data);\n          }\n        }\n      } // Use query data\n      else {\n          data = state.data;\n        } // Show placeholder data if needed\n\n\n    if (typeof this.options.placeholderData !== 'undefined' && typeof data === 'undefined' && status === 'loading') {\n      var placeholderData = typeof this.options.placeholderData === 'function' ? this.options.placeholderData() : this.options.placeholderData;\n\n      if (typeof placeholderData !== 'undefined') {\n        status = 'success';\n        data = placeholderData;\n        isPlaceholderData = true;\n      }\n    }\n\n    var result = _extends({}, getStatusProps(status), {\n      data: data,\n      dataUpdatedAt: dataUpdatedAt,\n      error: state.error,\n      errorUpdatedAt: state.errorUpdatedAt,\n      failureCount: state.fetchFailureCount,\n      isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,\n      isFetchedAfterMount: state.dataUpdateCount > this.initialDataUpdateCount || state.errorUpdateCount > this.initialErrorUpdateCount,\n      isFetching: isFetching,\n      isLoadingError: status === 'error' && state.dataUpdatedAt === 0,\n      isPlaceholderData: isPlaceholderData,\n      isPreviousData: isPreviousData,\n      isRefetchError: status === 'error' && state.dataUpdatedAt !== 0,\n      isStale: this.isStale(),\n      refetch: this.refetch,\n      remove: this.remove\n    });\n\n    return result;\n  };\n\n  _proto.shouldNotifyListeners = function shouldNotifyListeners(prevResult, result) {\n    var _this$options = this.options,\n        notifyOnChangeProps = _this$options.notifyOnChangeProps,\n        notifyOnChangePropsExclusions = _this$options.notifyOnChangePropsExclusions;\n\n    if (prevResult === result) {\n      return false;\n    }\n\n    if (!notifyOnChangeProps && !notifyOnChangePropsExclusions) {\n      return true;\n    }\n\n    var keys = Object.keys(result);\n\n    var _loop = function _loop(i) {\n      var key = keys[i];\n      var changed = prevResult[key] !== result[key];\n      var isIncluded = notifyOnChangeProps == null ? void 0 : notifyOnChangeProps.some(function (x) {\n        return x === key;\n      });\n      var isExcluded = notifyOnChangePropsExclusions == null ? void 0 : notifyOnChangePropsExclusions.some(function (x) {\n        return x === key;\n      });\n\n      if (changed) {\n        if (notifyOnChangePropsExclusions && isExcluded) {\n          return \"continue\";\n        }\n\n        if (!notifyOnChangeProps || isIncluded) {\n          return {\n            v: true\n          };\n        }\n      }\n    };\n\n    for (var i = 0; i < keys.length; i++) {\n      var _ret = _loop(i);\n\n      if (_ret === \"continue\") continue;\n      if (typeof _ret === \"object\") return _ret.v;\n    }\n\n    return false;\n  };\n\n  _proto.updateResult = function updateResult(willFetch) {\n    var result = this.getNewResult(willFetch); // Keep reference to the current state on which the current result is based on\n\n    this.currentResultState = this.currentQuery.state; // Only update if something has changed\n\n    if (!shallowEqualObjects(result, this.currentResult)) {\n      this.currentResult = result;\n    }\n  };\n\n  _proto.updateQuery = function updateQuery() {\n    var prevQuery = this.currentQuery;\n    var query = this.client.getQueryCache().build(this.client, this.options);\n\n    if (query === prevQuery) {\n      return;\n    }\n\n    this.previousQueryResult = this.currentResult;\n    this.currentQuery = query;\n    this.initialDataUpdateCount = query.state.dataUpdateCount;\n    this.initialErrorUpdateCount = query.state.errorUpdateCount;\n    var willFetch = prevQuery ? this.willFetchOptionally() : this.willFetchOnMount();\n    this.updateResult(willFetch);\n\n    if (!this.hasListeners()) {\n      return;\n    }\n\n    prevQuery == null ? void 0 : prevQuery.removeObserver(this);\n    this.currentQuery.addObserver(this);\n\n    if (this.shouldNotifyListeners(this.previousQueryResult, this.currentResult)) {\n      this.notify({\n        listeners: true\n      });\n    }\n  };\n\n  _proto.onQueryUpdate = function onQueryUpdate(action) {\n    // Store current result and get new result\n    var prevResult = this.currentResult;\n    this.updateResult();\n    var currentResult = this.currentResult; // Update timers\n\n    this.updateTimers(); // Do not notify if the nothing has changed\n\n    if (prevResult === currentResult) {\n      return;\n    } // Determine which callbacks to trigger\n\n\n    var notifyOptions = {};\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = true;\n    } else if (action.type === 'error') {\n      notifyOptions.onError = true;\n    }\n\n    if (this.shouldNotifyListeners(prevResult, currentResult)) {\n      notifyOptions.listeners = true;\n    }\n\n    this.notify(notifyOptions);\n  };\n\n  _proto.notify = function notify(notifyOptions) {\n    var _this6 = this;\n\n    notifyManager.batch(function () {\n      // First trigger the configuration callbacks\n      if (notifyOptions.onSuccess) {\n        _this6.options.onSuccess == null ? void 0 : _this6.options.onSuccess(_this6.currentResult.data);\n        _this6.options.onSettled == null ? void 0 : _this6.options.onSettled(_this6.currentResult.data, null);\n      } else if (notifyOptions.onError) {\n        _this6.options.onError == null ? void 0 : _this6.options.onError(_this6.currentResult.error);\n        _this6.options.onSettled == null ? void 0 : _this6.options.onSettled(undefined, _this6.currentResult.error);\n      } // Then trigger the listeners\n\n\n      if (notifyOptions.listeners) {\n        _this6.listeners.forEach(function (listener) {\n          listener(_this6.currentResult);\n        });\n      } // Then the cache listeners\n\n\n      if (notifyOptions.cache) {\n        _this6.client.getQueryCache().notify(_this6.currentQuery);\n      }\n    });\n  };\n\n  return QueryObserver;\n}(Subscribable);"]},"metadata":{},"sourceType":"module"}