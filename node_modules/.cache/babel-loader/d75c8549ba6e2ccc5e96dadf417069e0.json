{"ast":null,"code":"import { focusManager } from './focusManager';\nimport { onlineManager } from './onlineManager';\nimport { functionalUpdate, sleep } from './utils'; // TYPES\n\nfunction defaultRetryDelay(failureCount) {\n  return Math.min(1000 * Math.pow(2, failureCount), 30000);\n}\n\nexport function isCancelable(value) {\n  return typeof (value == null ? void 0 : value.cancel) === 'function';\n}\nexport var CancelledError = function CancelledError(options) {\n  this.revert = options == null ? void 0 : options.revert;\n  this.silent = options == null ? void 0 : options.silent;\n};\nexport function isCancelledError(value) {\n  return value instanceof CancelledError;\n} // CLASS\n\nexport var Retryer = function Retryer(config) {\n  var _this = this;\n\n  var cancelRetry = false;\n  var cancelFn;\n  var continueFn;\n  var promiseResolve;\n  var promiseReject;\n\n  this.cancel = function (cancelOptions) {\n    return cancelFn == null ? void 0 : cancelFn(cancelOptions);\n  };\n\n  this.cancelRetry = function () {\n    cancelRetry = true;\n  };\n\n  this.continue = function () {\n    return continueFn == null ? void 0 : continueFn();\n  };\n\n  this.failureCount = 0;\n  this.isPaused = false;\n  this.isResolved = false;\n  this.isTransportCancelable = false;\n  this.promise = new Promise(function (outerResolve, outerReject) {\n    promiseResolve = outerResolve;\n    promiseReject = outerReject;\n  });\n\n  var resolve = function resolve(value) {\n    _this.isResolved = true;\n    continueFn == null ? void 0 : continueFn();\n    promiseResolve(value);\n  };\n\n  var reject = function reject(value) {\n    _this.isResolved = true;\n    continueFn == null ? void 0 : continueFn();\n    promiseReject(value);\n  };\n\n  var pause = function pause() {\n    return new Promise(function (continueResolve) {\n      continueFn = continueResolve;\n      _this.isPaused = true;\n      config.onPause == null ? void 0 : config.onPause();\n    }).then(function () {\n      continueFn = undefined;\n      _this.isPaused = false;\n      config.onContinue == null ? void 0 : config.onContinue();\n    });\n  }; // Create loop function\n\n\n  var run = function run() {\n    // Do nothing if already resolved\n    if (_this.isResolved) {\n      return;\n    }\n\n    var promiseOrValue; // Execute query\n\n    try {\n      promiseOrValue = config.fn();\n    } catch (error) {\n      promiseOrValue = Promise.reject(error);\n    } // Create callback to cancel this fetch\n\n\n    cancelFn = function cancelFn(cancelOptions) {\n      reject(new CancelledError(cancelOptions)); // Cancel transport if supported\n\n      if (isCancelable(promiseOrValue)) {\n        try {\n          promiseOrValue.cancel();\n        } catch (_unused) {}\n      }\n    }; // Check if the transport layer support cancellation\n\n\n    _this.isTransportCancelable = isCancelable(promiseOrValue);\n    Promise.resolve(promiseOrValue).then(resolve).catch(function (error) {\n      var _config$retry, _config$retryDelay; // Stop if the fetch is already resolved\n\n\n      if (_this.isResolved) {\n        return;\n      } // Do we need to retry the request?\n\n\n      var retry = (_config$retry = config.retry) != null ? _config$retry : 3;\n      var retryDelay = (_config$retryDelay = config.retryDelay) != null ? _config$retryDelay : defaultRetryDelay;\n      var delay = functionalUpdate(retryDelay, _this.failureCount) || 0;\n      var shouldRetry = retry === true || typeof retry === 'number' && _this.failureCount < retry || typeof retry === 'function' && retry(_this.failureCount, error);\n\n      if (cancelRetry || !shouldRetry) {\n        // We are done if the query does not need to be retried\n        reject(error);\n        return;\n      }\n\n      _this.failureCount++; // Notify on fail\n\n      config.onFail == null ? void 0 : config.onFail(_this.failureCount, error); // Delay\n\n      sleep(delay) // Pause if the document is not visible or when the device is offline\n      .then(function () {\n        if (!focusManager.isFocused() || !onlineManager.isOnline()) {\n          return pause();\n        }\n      }).then(function () {\n        if (cancelRetry) {\n          reject(error);\n        } else {\n          run();\n        }\n      });\n    });\n  }; // Start loop\n\n\n  run();\n};","map":{"version":3,"sources":["/home/gudu/Desktop/react-shopping-cart-main/node_modules/react-query/es/core/retryer.js"],"names":["focusManager","onlineManager","functionalUpdate","sleep","defaultRetryDelay","failureCount","Math","min","pow","isCancelable","value","cancel","CancelledError","options","revert","silent","isCancelledError","Retryer","config","_this","cancelRetry","cancelFn","continueFn","promiseResolve","promiseReject","cancelOptions","continue","isPaused","isResolved","isTransportCancelable","promise","Promise","outerResolve","outerReject","resolve","reject","pause","continueResolve","onPause","then","undefined","onContinue","run","promiseOrValue","fn","error","_unused","catch","_config$retry","_config$retryDelay","retry","retryDelay","delay","shouldRetry","onFail","isFocused","isOnline"],"mappings":"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","sourcesContent":["import { focusManager } from './focusManager';\nimport { onlineManager } from './onlineManager';\nimport { functionalUpdate, sleep } from './utils'; // TYPES\n\nfunction defaultRetryDelay(failureCount) {\n  return Math.min(1000 * Math.pow(2, failureCount), 30000);\n}\n\nexport function isCancelable(value) {\n  return typeof (value == null ? void 0 : value.cancel) === 'function';\n}\nexport var CancelledError = function CancelledError(options) {\n  this.revert = options == null ? void 0 : options.revert;\n  this.silent = options == null ? void 0 : options.silent;\n};\nexport function isCancelledError(value) {\n  return value instanceof CancelledError;\n} // CLASS\n\nexport var Retryer = function Retryer(config) {\n  var _this = this;\n\n  var cancelRetry = false;\n  var cancelFn;\n  var continueFn;\n  var promiseResolve;\n  var promiseReject;\n\n  this.cancel = function (cancelOptions) {\n    return cancelFn == null ? void 0 : cancelFn(cancelOptions);\n  };\n\n  this.cancelRetry = function () {\n    cancelRetry = true;\n  };\n\n  this.continue = function () {\n    return continueFn == null ? void 0 : continueFn();\n  };\n\n  this.failureCount = 0;\n  this.isPaused = false;\n  this.isResolved = false;\n  this.isTransportCancelable = false;\n  this.promise = new Promise(function (outerResolve, outerReject) {\n    promiseResolve = outerResolve;\n    promiseReject = outerReject;\n  });\n\n  var resolve = function resolve(value) {\n    _this.isResolved = true;\n    continueFn == null ? void 0 : continueFn();\n    promiseResolve(value);\n  };\n\n  var reject = function reject(value) {\n    _this.isResolved = true;\n    continueFn == null ? void 0 : continueFn();\n    promiseReject(value);\n  };\n\n  var pause = function pause() {\n    return new Promise(function (continueResolve) {\n      continueFn = continueResolve;\n      _this.isPaused = true;\n      config.onPause == null ? void 0 : config.onPause();\n    }).then(function () {\n      continueFn = undefined;\n      _this.isPaused = false;\n      config.onContinue == null ? void 0 : config.onContinue();\n    });\n  }; // Create loop function\n\n\n  var run = function run() {\n    // Do nothing if already resolved\n    if (_this.isResolved) {\n      return;\n    }\n\n    var promiseOrValue; // Execute query\n\n    try {\n      promiseOrValue = config.fn();\n    } catch (error) {\n      promiseOrValue = Promise.reject(error);\n    } // Create callback to cancel this fetch\n\n\n    cancelFn = function cancelFn(cancelOptions) {\n      reject(new CancelledError(cancelOptions)); // Cancel transport if supported\n\n      if (isCancelable(promiseOrValue)) {\n        try {\n          promiseOrValue.cancel();\n        } catch (_unused) {}\n      }\n    }; // Check if the transport layer support cancellation\n\n\n    _this.isTransportCancelable = isCancelable(promiseOrValue);\n    Promise.resolve(promiseOrValue).then(resolve).catch(function (error) {\n      var _config$retry, _config$retryDelay;\n\n      // Stop if the fetch is already resolved\n      if (_this.isResolved) {\n        return;\n      } // Do we need to retry the request?\n\n\n      var retry = (_config$retry = config.retry) != null ? _config$retry : 3;\n      var retryDelay = (_config$retryDelay = config.retryDelay) != null ? _config$retryDelay : defaultRetryDelay;\n      var delay = functionalUpdate(retryDelay, _this.failureCount) || 0;\n      var shouldRetry = retry === true || typeof retry === 'number' && _this.failureCount < retry || typeof retry === 'function' && retry(_this.failureCount, error);\n\n      if (cancelRetry || !shouldRetry) {\n        // We are done if the query does not need to be retried\n        reject(error);\n        return;\n      }\n\n      _this.failureCount++; // Notify on fail\n\n      config.onFail == null ? void 0 : config.onFail(_this.failureCount, error); // Delay\n\n      sleep(delay) // Pause if the document is not visible or when the device is offline\n      .then(function () {\n        if (!focusManager.isFocused() || !onlineManager.isOnline()) {\n          return pause();\n        }\n      }).then(function () {\n        if (cancelRetry) {\n          reject(error);\n        } else {\n          run();\n        }\n      });\n    });\n  }; // Start loop\n\n\n  run();\n};"]},"metadata":{},"sourceType":"module"}