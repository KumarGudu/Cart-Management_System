{"ast":null,"code":"import { isCancelable } from './retryer';\nexport function infiniteQueryBehavior() {\n  return {\n    onFetch: function onFetch(context) {\n      context.fetchFn = function () {\n        var _context$fetchOptions, _context$fetchOptions2, _context$state$data, _context$state$data2;\n\n        var fetchMore = (_context$fetchOptions = context.fetchOptions) == null ? void 0 : (_context$fetchOptions2 = _context$fetchOptions.meta) == null ? void 0 : _context$fetchOptions2.fetchMore;\n        var pageParam = fetchMore == null ? void 0 : fetchMore.pageParam;\n        var isFetchingNextPage = (fetchMore == null ? void 0 : fetchMore.direction) === 'forward';\n        var isFetchingPreviousPage = (fetchMore == null ? void 0 : fetchMore.direction) === 'backward';\n        var oldPages = ((_context$state$data = context.state.data) == null ? void 0 : _context$state$data.pages) || [];\n        var oldPageParams = ((_context$state$data2 = context.state.data) == null ? void 0 : _context$state$data2.pageParams) || [];\n        var newPageParams = oldPageParams; // Get query function\n\n        var queryFn = context.options.queryFn || function () {\n          return Promise.reject('Missing queryFn');\n        }; // Create function to fetch a page\n\n\n        var fetchPage = function fetchPage(pages, manual, param, previous) {\n          if (typeof param === 'undefined' && !manual && pages.length) {\n            return Promise.resolve(pages);\n          }\n\n          var queryFnContext = {\n            queryKey: context.queryKey,\n            pageParam: param\n          };\n          var cancelFn;\n          var queryFnResult = queryFn(queryFnContext);\n\n          if (queryFnResult.cancel) {\n            cancelFn = queryFnResult.cancel;\n          }\n\n          var promise = Promise.resolve(queryFnResult).then(function (page) {\n            newPageParams = previous ? [param].concat(newPageParams) : [].concat(newPageParams, [param]);\n            return previous ? [page].concat(pages) : [].concat(pages, [page]);\n          });\n\n          if (cancelFn) {\n            var promiseAsAny = promise;\n            promiseAsAny.cancel = cancelFn;\n          }\n\n          return promise;\n        };\n\n        var promise; // Fetch first page?\n\n        if (!oldPages.length) {\n          promise = fetchPage([]);\n        } // Fetch next page?\n        else if (isFetchingNextPage) {\n            var manual = typeof pageParam !== 'undefined';\n            var param = manual ? pageParam : getNextPageParam(context.options, oldPages);\n            promise = fetchPage(oldPages, manual, param);\n          } // Fetch previous page?\n          else if (isFetchingPreviousPage) {\n              var _manual = typeof pageParam !== 'undefined';\n\n              var _param = _manual ? pageParam : getPreviousPageParam(context.options, oldPages);\n\n              promise = fetchPage(oldPages, _manual, _param, true);\n            } // Refetch pages\n            else {\n                (function () {\n                  newPageParams = [];\n                  var manual = typeof context.options.getNextPageParam === 'undefined'; // Fetch first page\n\n                  promise = fetchPage([], manual, oldPageParams[0]); // Fetch remaining pages\n\n                  var _loop = function _loop(i) {\n                    promise = promise.then(function (pages) {\n                      var param = manual ? oldPageParams[i] : getNextPageParam(context.options, pages);\n                      return fetchPage(pages, manual, param);\n                    });\n                  };\n\n                  for (var i = 1; i < oldPages.length; i++) {\n                    _loop(i);\n                  }\n                })();\n              }\n\n        var finalPromise = promise.then(function (pages) {\n          return {\n            pages: pages,\n            pageParams: newPageParams\n          };\n        });\n\n        if (isCancelable(promise)) {\n          var finalPromiseAsAny = finalPromise;\n          finalPromiseAsAny.cancel = promise.cancel;\n        }\n\n        return finalPromise;\n      };\n    }\n  };\n}\nexport function getNextPageParam(options, pages) {\n  return options.getNextPageParam == null ? void 0 : options.getNextPageParam(pages[pages.length - 1], pages);\n}\nexport function getPreviousPageParam(options, pages) {\n  return options.getPreviousPageParam == null ? void 0 : options.getPreviousPageParam(pages[0], pages);\n}\n/**\n * Checks if there is a next page.\n * Returns `undefined` if it cannot be determined.\n */\n\nexport function hasNextPage(options, pages) {\n  if (options.getNextPageParam && Array.isArray(pages)) {\n    var nextPageParam = getNextPageParam(options, pages);\n    return typeof nextPageParam !== 'undefined' && nextPageParam !== null && nextPageParam !== false;\n  }\n}\n/**\n * Checks if there is a previous page.\n * Returns `undefined` if it cannot be determined.\n */\n\nexport function hasPreviousPage(options, pages) {\n  if (options.getPreviousPageParam && Array.isArray(pages)) {\n    var previousPageParam = getPreviousPageParam(options, pages);\n    return typeof previousPageParam !== 'undefined' && previousPageParam !== null && previousPageParam !== false;\n  }\n}","map":{"version":3,"sources":["/home/gudu/Desktop/react-shopping-cart-main/node_modules/react-query/es/core/infiniteQueryBehavior.js"],"names":["isCancelable","infiniteQueryBehavior","onFetch","context","fetchFn","_context$fetchOptions","_context$fetchOptions2","_context$state$data","_context$state$data2","fetchMore","fetchOptions","meta","pageParam","isFetchingNextPage","direction","isFetchingPreviousPage","oldPages","state","data","pages","oldPageParams","pageParams","newPageParams","queryFn","options","Promise","reject","fetchPage","manual","param","previous","length","resolve","queryFnContext","queryKey","cancelFn","queryFnResult","cancel","promise","then","page","concat","promiseAsAny","getNextPageParam","_manual","_param","getPreviousPageParam","_loop","i","finalPromise","finalPromiseAsAny","hasNextPage","Array","isArray","nextPageParam","hasPreviousPage","previousPageParam"],"mappings":"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","sourcesContent":["import { isCancelable } from './retryer';\nexport function infiniteQueryBehavior() {\n  return {\n    onFetch: function onFetch(context) {\n      context.fetchFn = function () {\n        var _context$fetchOptions, _context$fetchOptions2, _context$state$data, _context$state$data2;\n\n        var fetchMore = (_context$fetchOptions = context.fetchOptions) == null ? void 0 : (_context$fetchOptions2 = _context$fetchOptions.meta) == null ? void 0 : _context$fetchOptions2.fetchMore;\n        var pageParam = fetchMore == null ? void 0 : fetchMore.pageParam;\n        var isFetchingNextPage = (fetchMore == null ? void 0 : fetchMore.direction) === 'forward';\n        var isFetchingPreviousPage = (fetchMore == null ? void 0 : fetchMore.direction) === 'backward';\n        var oldPages = ((_context$state$data = context.state.data) == null ? void 0 : _context$state$data.pages) || [];\n        var oldPageParams = ((_context$state$data2 = context.state.data) == null ? void 0 : _context$state$data2.pageParams) || [];\n        var newPageParams = oldPageParams; // Get query function\n\n        var queryFn = context.options.queryFn || function () {\n          return Promise.reject('Missing queryFn');\n        }; // Create function to fetch a page\n\n\n        var fetchPage = function fetchPage(pages, manual, param, previous) {\n          if (typeof param === 'undefined' && !manual && pages.length) {\n            return Promise.resolve(pages);\n          }\n\n          var queryFnContext = {\n            queryKey: context.queryKey,\n            pageParam: param\n          };\n          var cancelFn;\n          var queryFnResult = queryFn(queryFnContext);\n\n          if (queryFnResult.cancel) {\n            cancelFn = queryFnResult.cancel;\n          }\n\n          var promise = Promise.resolve(queryFnResult).then(function (page) {\n            newPageParams = previous ? [param].concat(newPageParams) : [].concat(newPageParams, [param]);\n            return previous ? [page].concat(pages) : [].concat(pages, [page]);\n          });\n\n          if (cancelFn) {\n            var promiseAsAny = promise;\n            promiseAsAny.cancel = cancelFn;\n          }\n\n          return promise;\n        };\n\n        var promise; // Fetch first page?\n\n        if (!oldPages.length) {\n          promise = fetchPage([]);\n        } // Fetch next page?\n        else if (isFetchingNextPage) {\n            var manual = typeof pageParam !== 'undefined';\n            var param = manual ? pageParam : getNextPageParam(context.options, oldPages);\n            promise = fetchPage(oldPages, manual, param);\n          } // Fetch previous page?\n          else if (isFetchingPreviousPage) {\n              var _manual = typeof pageParam !== 'undefined';\n\n              var _param = _manual ? pageParam : getPreviousPageParam(context.options, oldPages);\n\n              promise = fetchPage(oldPages, _manual, _param, true);\n            } // Refetch pages\n            else {\n                (function () {\n                  newPageParams = [];\n                  var manual = typeof context.options.getNextPageParam === 'undefined'; // Fetch first page\n\n                  promise = fetchPage([], manual, oldPageParams[0]); // Fetch remaining pages\n\n                  var _loop = function _loop(i) {\n                    promise = promise.then(function (pages) {\n                      var param = manual ? oldPageParams[i] : getNextPageParam(context.options, pages);\n                      return fetchPage(pages, manual, param);\n                    });\n                  };\n\n                  for (var i = 1; i < oldPages.length; i++) {\n                    _loop(i);\n                  }\n                })();\n              }\n\n        var finalPromise = promise.then(function (pages) {\n          return {\n            pages: pages,\n            pageParams: newPageParams\n          };\n        });\n\n        if (isCancelable(promise)) {\n          var finalPromiseAsAny = finalPromise;\n          finalPromiseAsAny.cancel = promise.cancel;\n        }\n\n        return finalPromise;\n      };\n    }\n  };\n}\nexport function getNextPageParam(options, pages) {\n  return options.getNextPageParam == null ? void 0 : options.getNextPageParam(pages[pages.length - 1], pages);\n}\nexport function getPreviousPageParam(options, pages) {\n  return options.getPreviousPageParam == null ? void 0 : options.getPreviousPageParam(pages[0], pages);\n}\n/**\n * Checks if there is a next page.\n * Returns `undefined` if it cannot be determined.\n */\n\nexport function hasNextPage(options, pages) {\n  if (options.getNextPageParam && Array.isArray(pages)) {\n    var nextPageParam = getNextPageParam(options, pages);\n    return typeof nextPageParam !== 'undefined' && nextPageParam !== null && nextPageParam !== false;\n  }\n}\n/**\n * Checks if there is a previous page.\n * Returns `undefined` if it cannot be determined.\n */\n\nexport function hasPreviousPage(options, pages) {\n  if (options.getPreviousPageParam && Array.isArray(pages)) {\n    var previousPageParam = getPreviousPageParam(options, pages);\n    return typeof previousPageParam !== 'undefined' && previousPageParam !== null && previousPageParam !== false;\n  }\n}"]},"metadata":{},"sourceType":"module"}